(**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *)

unit tutorial;

interface

uses
  Classes,
  SysUtils,
  Generics.Collections,
  Thrift,
  Thrift.Utils,
  Thrift.Collections,
  Thrift.Protocol,
  Thrift.Transport,
  shared;

const
  ctutorial_Option_AnsiStr_Binary = False;
  ctutorial_Option_Register_Types = False;
  ctutorial_Option_ConstPrefix    = False;
  ctutorial_Option_Events         = False;
  ctutorial_Option_XmlDoc         = False;

type
  IWork = interface;
  TInvalidOperation = class;


{$SCOPEDENUMS ON}

  TOperation = (
    ADD = 1,
    SUBTRACT = 2,
    MULTIPLY = 3,
    DIVIDE = 4
  );

{$SCOPEDENUMS OFF}

  TMyInteger = System.Integer;

  IWork = interface(IBase)
    function GetNum1: System.Integer;
    procedure SetNum1( const Value: System.Integer);
    function GetNum2: System.Integer;
    procedure SetNum2( const Value: System.Integer);
    function GetOp: TOperation;
    procedure SetOp( const Value: TOperation);
    function GetComment: System.string;
    procedure SetComment( const Value: System.string);

    property Num1: System.Integer read GetNum1 write SetNum1;
    property Num2: System.Integer read GetNum2 write SetNum2;
    property Op: TOperation read GetOp write SetOp;
    property Comment: System.string read GetComment write SetComment;

    function Get__isset_Num1: System.Boolean;
    function Get__isset_Num2: System.Boolean;
    function Get__isset_Op: System.Boolean;
    function Get__isset_Comment: System.Boolean;

    property __isset_Num1: System.Boolean read Get__isset_Num1;
    property __isset_Num2: System.Boolean read Get__isset_Num2;
    property __isset_Op: System.Boolean read Get__isset_Op;
    property __isset_Comment: System.Boolean read Get__isset_Comment;
  end;

  TWorkImpl = class(TInterfacedObject, IBase, ISupportsToString, IWork)
  private
    FNum1: System.Integer;
    FNum2: System.Integer;
    FOp: TOperation;
    FComment: System.string;
    
    F__isset_Num1: System.Boolean;
    F__isset_Num2: System.Boolean;
    F__isset_Op: System.Boolean;
    F__isset_Comment: System.Boolean;
    
    function GetNum1: System.Integer;
    procedure SetNum1( const Value: System.Integer);
    function GetNum2: System.Integer;
    procedure SetNum2( const Value: System.Integer);
    function GetOp: TOperation;
    procedure SetOp( const Value: TOperation);
    function GetComment: System.string;
    procedure SetComment( const Value: System.string);

    function Get__isset_Num1: System.Boolean;
    function Get__isset_Num2: System.Boolean;
    function Get__isset_Op: System.Boolean;
    function Get__isset_Comment: System.Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; override;

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Num1: System.Integer read GetNum1 write SetNum1;
    property Num2: System.Integer read GetNum2 write SetNum2;
    property Op: TOperation read GetOp write SetOp;
    property Comment: System.string read GetComment write SetComment;

    // isset
    property __isset_Num1: System.Boolean read Get__isset_Num1;
    property __isset_Num2: System.Boolean read Get__isset_Num2;
    property __isset_Op: System.Boolean read Get__isset_Op;
    property __isset_Comment: System.Boolean read Get__isset_Comment;
  end;

  TInvalidOperation = class(TException)
  public
    type
      IInvalidOperationFactory = interface(IBase)
        function GetWhatOp: System.Integer;
        procedure SetWhatOp( const Value: System.Integer);
        function GetWhy: System.string;
        procedure SetWhy( const Value: System.string);

        // Create Exception Object
        function CreateException: TInvalidOperation;

        property WhatOp: System.Integer read GetWhatOp write SetWhatOp;
        property Why: System.string read GetWhy write SetWhy;

        function Get__isset_WhatOp: System.Boolean;
        function Get__isset_Why: System.Boolean;

        property __isset_WhatOp: System.Boolean read Get__isset_WhatOp;
        property __isset_Why: System.Boolean read Get__isset_Why;
      end;

      TInvalidOperationFactoryImpl = class(TInterfacedObject, IBase, ISupportsToString, IInvalidOperationFactory)
      private
        FWhatOp: System.Integer;
        FWhy: System.string;
        
        F__isset_WhatOp: System.Boolean;
        F__isset_Why: System.Boolean;
        
        function GetWhatOp: System.Integer;
        procedure SetWhatOp( const Value: System.Integer);
        function GetWhy: System.string;
        procedure SetWhy( const Value: System.string);

        function Get__isset_WhatOp: System.Boolean;
        function Get__isset_Why: System.Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Create Exception Object
        function CreateException: TInvalidOperation;

        // Properties
        property WhatOp: System.Integer read GetWhatOp write SetWhatOp;
        property Why: System.string read GetWhy write SetWhy;

        // isset
        property __isset_WhatOp: System.Boolean read Get__isset_WhatOp;
        property __isset_Why: System.Boolean read Get__isset_Why;
      end;

  private
    FInvalidOperationFactory :IInvalidOperationFactory;

    FWhatOp: System.Integer;
    FWhy: System.string;
    
    F__isset_WhatOp: System.Boolean;
    F__isset_Why: System.Boolean;
    
    function GetWhatOp: System.Integer;
    procedure SetWhatOp( const Value: System.Integer);
    function GetWhy: System.string;
    procedure SetWhy( const Value: System.string);

    function Get__isset_WhatOp: System.Boolean;
    function Get__isset_Why: System.Boolean;
  public
    constructor Create; overload;
    constructor Create( AWhatOp: System.Integer; const AWhy: System.string); overload;
    destructor Destroy; override;

    function ToString: string; override;

    // Exception Factory
    function InvalidOperationFactory: IInvalidOperationFactory;

    // Properties
    property WhatOp: System.Integer read GetWhatOp write SetWhatOp;
    property Why: System.string read GetWhy write SetWhy;

    // isset
    property __isset_WhatOp: System.Boolean read Get__isset_WhatOp;
    property __isset_Why: System.Boolean read Get__isset_Why;
  end;

  TCalculator = class
  public
    type
      Iface = interface(TSharedService.Iface)
        procedure ping();
        function pesquisaPontos(num1: System.Integer; num2: System.Integer): System.Integer;
        function calculate(logid: System.Integer; const w: IWork): System.Integer;
        procedure zip();
      end;

      TClient = class( TSharedService.TClient, Iface)
      public
        constructor Create( prot: IProtocol); overload;
        constructor Create( const iprot: IProtocol; const oprot: IProtocol); overload;
      protected
        // Iface
        procedure ping();
        function pesquisaPontos(num1: System.Integer; num2: System.Integer): System.Integer;
        function calculate(logid: System.Integer; const w: IWork): System.Integer;
        procedure zip();
      public
        procedure send_ping();
        procedure recv_ping();
        procedure send_pesquisaPontos(num1: System.Integer; num2: System.Integer);
        function recv_pesquisaPontos(): System.Integer;
        procedure send_calculate(logid: System.Integer; const w: IWork);
        function recv_calculate(): System.Integer;
        procedure send_zip();
      end;

      TProcessorImpl = class(TSharedService.TProcessorImpl, IProcessor)
      public
        constructor Create( iface_: Iface );
        destructor Destroy; override;
      private
        iface_: Iface;
      public
        function Process( const iprot: IProtocol; const oprot: IProtocol; const events : IProcessorEvents): System.Boolean; reintroduce;
        procedure ping_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
        procedure pesquisaPontos_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
        procedure calculate_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
        procedure zip_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
      end;

      IPing_args = interface(IBase)
      end;

      TPing_argsImpl = class(TInterfacedObject, IBase, ISupportsToString, IPing_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IPing_result = interface(IBase)
      end;

      TPing_resultImpl = class(TInterfacedObject, IBase, ISupportsToString, IPing_result)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

      IAdd_args = interface(IBase)
        function GetNum1: System.Integer;
        procedure SetNum1( const Value: System.Integer);
        function GetNum2: System.Integer;
        procedure SetNum2( const Value: System.Integer);

        property Num1: System.Integer read GetNum1 write SetNum1;
        property Num2: System.Integer read GetNum2 write SetNum2;

        function Get__isset_Num1: System.Boolean;
        function Get__isset_Num2: System.Boolean;

        property __isset_Num1: System.Boolean read Get__isset_Num1;
        property __isset_Num2: System.Boolean read Get__isset_Num2;
      end;

      TAdd_argsImpl = class(TInterfacedObject, IBase, ISupportsToString, IAdd_args)
      private
        FNum1: System.Integer;
        FNum2: System.Integer;
        
        F__isset_Num1: System.Boolean;
        F__isset_Num2: System.Boolean;
        
        function GetNum1: System.Integer;
        procedure SetNum1( const Value: System.Integer);
        function GetNum2: System.Integer;
        procedure SetNum2( const Value: System.Integer);

        function Get__isset_Num1: System.Boolean;
        function Get__isset_Num2: System.Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Num1: System.Integer read GetNum1 write SetNum1;
        property Num2: System.Integer read GetNum2 write SetNum2;

        // isset
        property __isset_Num1: System.Boolean read Get__isset_Num1;
        property __isset_Num2: System.Boolean read Get__isset_Num2;
      end;

      IAdd_result = interface(IBase)
        function GetSuccess: System.Integer;
        procedure SetSuccess( const Value: System.Integer);

        property Success: System.Integer read GetSuccess write SetSuccess;

        function Get__isset_Success: System.Boolean;

        property __isset_Success: System.Boolean read Get__isset_Success;
      end;

      TAdd_resultImpl = class(TInterfacedObject, IBase, ISupportsToString, IAdd_result)
      private
        FSuccess: System.Integer;
        
        F__isset_Success: System.Boolean;
        
        function GetSuccess: System.Integer;
        procedure SetSuccess( const Value: System.Integer);

        function Get__isset_Success: System.Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: System.Integer read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: System.Boolean read Get__isset_Success;
      end;

      ICalculate_args = interface(IBase)
        function GetLogid: System.Integer;
        procedure SetLogid( const Value: System.Integer);
        function GetW: IWork;
        procedure SetW( const Value: IWork);

        property Logid: System.Integer read GetLogid write SetLogid;
        property W: IWork read GetW write SetW;

        function Get__isset_Logid: System.Boolean;
        function Get__isset_W: System.Boolean;

        property __isset_Logid: System.Boolean read Get__isset_Logid;
        property __isset_W: System.Boolean read Get__isset_W;
      end;

      TCalculate_argsImpl = class(TInterfacedObject, IBase, ISupportsToString, ICalculate_args)
      private
        FLogid: System.Integer;
        FW: IWork;
        
        F__isset_Logid: System.Boolean;
        F__isset_W: System.Boolean;
        
        function GetLogid: System.Integer;
        procedure SetLogid( const Value: System.Integer);
        function GetW: IWork;
        procedure SetW( const Value: IWork);

        function Get__isset_Logid: System.Boolean;
        function Get__isset_W: System.Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Logid: System.Integer read GetLogid write SetLogid;
        property W: IWork read GetW write SetW;

        // isset
        property __isset_Logid: System.Boolean read Get__isset_Logid;
        property __isset_W: System.Boolean read Get__isset_W;
      end;

      ICalculate_result = interface(IBase)
        function GetSuccess: System.Integer;
        procedure SetSuccess( const Value: System.Integer);
        function GetOuch: TInvalidOperation.IInvalidOperationFactory;
        procedure SetOuch( const Value: TInvalidOperation.IInvalidOperationFactory);

        property Success: System.Integer read GetSuccess write SetSuccess;
        property Ouch: TInvalidOperation.IInvalidOperationFactory read GetOuch write SetOuch;

        function Get__isset_Success: System.Boolean;
        function Get__isset_Ouch: System.Boolean;

        property __isset_Success: System.Boolean read Get__isset_Success;
        property __isset_Ouch: System.Boolean read Get__isset_Ouch;
      end;

      TCalculate_resultImpl = class(TInterfacedObject, IBase, ISupportsToString, ICalculate_result)
      private
        FSuccess: System.Integer;
        FOuch: TInvalidOperation.IInvalidOperationFactory;
        
        F__isset_Success: System.Boolean;
        F__isset_Ouch: System.Boolean;
        
        function GetSuccess: System.Integer;
        procedure SetSuccess( const Value: System.Integer);
        function GetOuch: TInvalidOperation.IInvalidOperationFactory;
        procedure SetOuch( const Value: TInvalidOperation.IInvalidOperationFactory);

        function Get__isset_Success: System.Boolean;
        function Get__isset_Ouch: System.Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: System.Integer read GetSuccess write SetSuccess;
        property Ouch: TInvalidOperation.IInvalidOperationFactory read GetOuch write SetOuch;

        // isset
        property __isset_Success: System.Boolean read Get__isset_Success;
        property __isset_Ouch: System.Boolean read Get__isset_Ouch;
      end;

      IZip_args = interface(IBase)
      end;

      TZip_argsImpl = class(TInterfacedObject, IBase, ISupportsToString, IZip_args)
      private
        
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);
      end;

  end;
  
  TConstants = class
  private
    class var FMAPCONSTANT: IThriftDictionary<System.string, System.string>;
  public
    const INT32CONSTANT = LongInt( 9853);
    class property MAPCONSTANT: IThriftDictionary<System.string, System.string> read FMAPCONSTANT;
    {$IF CompilerVersion >= 21.0}
    class constructor Create;
    class destructor Destroy;
    {$IFEND}
  end;

implementation

constructor TWorkImpl.Create;
begin
  inherited;
  F__isset_Num1 := True;
end;

destructor TWorkImpl.Destroy;
begin
  inherited;
end;

function TWorkImpl.GetNum1: System.Integer;
begin
  Result := FNum1;
end;

procedure TWorkImpl.SetNum1( const Value: System.Integer);
begin
  F__isset_Num1 := True;
  FNum1 := Value;
end;

function TWorkImpl.Get__isset_Num1: System.Boolean;
begin
  Result := F__isset_Num1;
end;

function TWorkImpl.GetNum2: System.Integer;
begin
  Result := FNum2;
end;

procedure TWorkImpl.SetNum2( const Value: System.Integer);
begin
  F__isset_Num2 := True;
  FNum2 := Value;
end;

function TWorkImpl.Get__isset_Num2: System.Boolean;
begin
  Result := F__isset_Num2;
end;

function TWorkImpl.GetOp: TOperation;
begin
  Result := FOp;
end;

procedure TWorkImpl.SetOp( const Value: TOperation);
begin
  F__isset_Op := True;
  FOp := Value;
end;

function TWorkImpl.Get__isset_Op: System.Boolean;
begin
  Result := F__isset_Op;
end;

function TWorkImpl.GetComment: System.string;
begin
  Result := FComment;
end;

procedure TWorkImpl.SetComment( const Value: System.string);
begin
  F__isset_Comment := True;
  FComment := Value;
end;

function TWorkImpl.Get__isset_Comment: System.Boolean;
begin
  Result := F__isset_Comment;
end;

procedure TWorkImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Num1 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Num2 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        3: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Op := TOperation(iprot.ReadI32());
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        4: begin
          if (field_.Type_ = TType.String_) then begin
            Self.Comment := iprot.ReadString();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TWorkImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'Work');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Num1) then begin
    field_.Name := 'num1';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Num1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Num2) then begin
    field_.Name := 'num2';
    field_.Type_  := TType.I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Num2);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Op) then begin
    field_.Name := 'op';
    field_.Type_  := TType.I32;
    field_.ID := 3;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(System.Integer(Self.Op));
    oprot.WriteFieldEnd();
  end;
  if (__isset_Comment) then begin
    field_.Name := 'comment';
    field_.Type_  := TType.String_;
    field_.ID := 4;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Self.Comment);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TWorkImpl.ToString: string;
var
  _sb0 : TThriftStringBuilder;
  _first1 : System.Boolean;
begin
  _sb0 := TThriftStringBuilder.Create('(');
  try
    _first1 := TRUE;
    if (__isset_Num1) then begin
      if not _first1 then _sb0.Append(',');
      _first1 := FALSE;
      _sb0.Append('Num1: ');
      _sb0.Append( Self.Num1);
    end;
    if (__isset_Num2) then begin
      if not _first1 then _sb0.Append(',');
      _first1 := FALSE;
      _sb0.Append('Num2: ');
      _sb0.Append( Self.Num2);
    end;
    if (__isset_Op) then begin
      if not _first1 then _sb0.Append(',');
      _first1 := FALSE;
      _sb0.Append('Op: ');
      _sb0.Append(EnumUtils<TOperation>.ToString( System.Ord( Self.Op)));
    end;
    if (__isset_Comment) then begin
      if not _first1 then _sb0.Append(',');
      _first1 := FALSE;
      _sb0.Append('Comment: ');
      _sb0.Append( Self.Comment);
    end;
    _sb0.Append(')');
    Result := _sb0.ToString;
    if _first1 then {prevent warning};
  finally
    _sb0.Free;
  end;
end;

constructor TInvalidOperation.TInvalidOperationFactoryImpl.Create;
begin
  inherited;
end;

destructor TInvalidOperation.TInvalidOperationFactoryImpl.Destroy;
begin
  inherited;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.GetWhatOp: System.Integer;
begin
  Result := FWhatOp;
end;

procedure TInvalidOperation.TInvalidOperationFactoryImpl.SetWhatOp( const Value: System.Integer);
begin
  F__isset_WhatOp := True;
  FWhatOp := Value;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.Get__isset_WhatOp: System.Boolean;
begin
  Result := F__isset_WhatOp;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.GetWhy: System.string;
begin
  Result := FWhy;
end;

procedure TInvalidOperation.TInvalidOperationFactoryImpl.SetWhy( const Value: System.string);
begin
  F__isset_Why := True;
  FWhy := Value;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.Get__isset_Why: System.Boolean;
begin
  Result := F__isset_Why;
end;

procedure TInvalidOperation.TInvalidOperationFactoryImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.WhatOp := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = TType.String_) then begin
            Self.Why := iprot.ReadString();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TInvalidOperation.TInvalidOperationFactoryImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'InvalidOperation');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_WhatOp) then begin
    field_.Name := 'whatOp';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.WhatOp);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Why) then begin
    field_.Name := 'why';
    field_.Type_  := TType.String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Self.Why);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.ToString: string;
var
  _sb2 : TThriftStringBuilder;
  _first3 : System.Boolean;
begin
  _sb2 := TThriftStringBuilder.Create('(');
  try
    _first3 := TRUE;
    if (__isset_WhatOp) then begin
      if not _first3 then _sb2.Append(',');
      _first3 := FALSE;
      _sb2.Append('WhatOp: ');
      _sb2.Append( Self.WhatOp);
    end;
    if (__isset_Why) then begin
      if not _first3 then _sb2.Append(',');
      _first3 := FALSE;
      _sb2.Append('Why: ');
      _sb2.Append( Self.Why);
    end;
    _sb2.Append(')');
    Result := _sb2.ToString;
    if _first3 then {prevent warning};
  finally
    _sb2.Free;
  end;
end;

function TInvalidOperation.TInvalidOperationFactoryImpl.CreateException: TInvalidOperation;
begin
  Result := TInvalidOperation.Create;
  Result.FInvalidOperationFactory := Self;
  if __isset_WhatOp then begin
    Result.WhatOp := WhatOp;
  end;
  if __isset_Why then begin
    Result.Why := Why;
  end;
  Result.UpdateMessageProperty;
end;

constructor TInvalidOperation.Create;
begin
  inherited Create('');
end;

constructor TInvalidOperation.Create( AWhatOp: System.Integer; const AWhy: System.string);
begin
  Create;
  WhatOp := AWhatOp;
  Why := AWhy;
  UpdateMessageProperty;
end;

destructor TInvalidOperation.Destroy;
begin
  inherited;
end;

function TInvalidOperation.InvalidOperationFactory: IInvalidOperationFactory;
begin
  if FInvalidOperationFactory = nil
  then FInvalidOperationFactory := TInvalidOperationFactoryImpl.Create;
  
  result := FInvalidOperationFactory;
end;

function TInvalidOperation.GetWhatOp: System.Integer;
begin
  Result := FWhatOp;
end;

procedure TInvalidOperation.SetWhatOp( const Value: System.Integer);
begin
  F__isset_WhatOp := True;
  FWhatOp := Value;
  InvalidOperationFactory.WhatOp := Value;
end;

function TInvalidOperation.Get__isset_WhatOp: System.Boolean;
begin
  Result := F__isset_WhatOp;
end;

function TInvalidOperation.GetWhy: System.string;
begin
  Result := FWhy;
end;

procedure TInvalidOperation.SetWhy( const Value: System.string);
begin
  F__isset_Why := True;
  FWhy := Value;
  InvalidOperationFactory.Why := Value;
end;

function TInvalidOperation.Get__isset_Why: System.Boolean;
begin
  Result := F__isset_Why;
end;

function TInvalidOperation.ToString: string;
var
  _sb4 : TThriftStringBuilder;
  _first5 : System.Boolean;
begin
  _sb4 := TThriftStringBuilder.Create('(');
  try
    _first5 := TRUE;
    if (__isset_WhatOp) then begin
      if not _first5 then _sb4.Append(',');
      _first5 := FALSE;
      _sb4.Append('WhatOp: ');
      _sb4.Append( Self.WhatOp);
    end;
    if (__isset_Why) then begin
      if not _first5 then _sb4.Append(',');
      _first5 := FALSE;
      _sb4.Append('Why: ');
      _sb4.Append( Self.Why);
    end;
    _sb4.Append(')');
    Result := _sb4.ToString;
    if _first5 then {prevent warning};
  finally
    _sb4.Free;
  end;
end;

constructor TCalculator.TClient.Create( prot: IProtocol);
begin
  Create( prot, prot );
end;

constructor TCalculator.TClient.Create( const iprot: IProtocol; const oprot: IProtocol);
begin
  inherited Create;
  iprot_ := iprot;
  oprot_ := oprot;
end;

procedure TCalculator.TClient.ping();
begin
  send_ping();
  recv_ping();
end;

procedure TCalculator.TClient.send_ping();
var
  _args6 : IPing_args;
  _msg7 : Thrift.Protocol.TThriftMessage;
begin
  seqid_ := seqid_ + 1;
  Thrift.Protocol.Init( _msg7, 'ping', TMessageType.Call, seqid_);
  oprot_.WriteMessageBegin( _msg7 );
  _args6 := TPing_argsImpl.Create();
  _args6.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

procedure TCalculator.TClient.recv_ping();
var
  _msg7 : Thrift.Protocol.TThriftMessage;
  _ax9 : TApplicationException;
  _ret10 : IPing_result;
begin
  _msg7 := iprot_.ReadMessageBegin();
  if (_msg7.Type_ = TMessageType.Exception) then
  begin
    _ax9 := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise _ax9;
  end;
  _ret10 := TPing_resultImpl.Create();
  _ret10.Read(iprot_);
  iprot_.ReadMessageEnd();
end;

function TCalculator.TClient.pesquisaPontos(num1: System.Integer; num2: System.Integer): System.Integer;
begin
  send_pesquisaPontos(num1, num2);
  Result := recv_pesquisaPontos();
end;

procedure TCalculator.TClient.send_pesquisaPontos(num1: System.Integer; num2: System.Integer);
var
  _args11 : IAdd_args;
  _msg12 : Thrift.Protocol.TThriftMessage;
begin
  seqid_ := seqid_ + 1;
  Thrift.Protocol.Init( _msg12, 'pesquisaPontos', TMessageType.Call, seqid_);
  oprot_.WriteMessageBegin( _msg12 );
  _args11 := TAdd_argsImpl.Create();
  _args11.Num1 := num1;
  _args11.Num2 := num2;
  _args11.Write(oprot_);
  _args11.Num1 := 0;
  _args11.Num2 := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TCalculator.TClient.recv_pesquisaPontos(): System.Integer;
var
  _msg12 : Thrift.Protocol.TThriftMessage;
  _ax14 : TApplicationException;
  _ret15 : IAdd_result;
begin
  _msg12 := iprot_.ReadMessageBegin();
  if (_msg12.Type_ = TMessageType.Exception) then
  begin
    _ax14 := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise _ax14;
  end;
  _ret15 := TAdd_resultImpl.Create();
  _ret15.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (_ret15.__isset_success) then
  begin
    Result := _ret15.Success;
    Exit;
  end;
  raise TApplicationExceptionMissingResult.Create('pesquisaPontos failed: unknown result');
end;

function TCalculator.TClient.calculate(logid: System.Integer; const w: IWork): System.Integer;
begin
  send_calculate(logid, w);
  Result := recv_calculate();
end;

procedure TCalculator.TClient.send_calculate(logid: System.Integer; const w: IWork);
var
  _args16 : ICalculate_args;
  _msg17 : Thrift.Protocol.TThriftMessage;
begin
  seqid_ := seqid_ + 1;
  Thrift.Protocol.Init( _msg17, 'calculate', TMessageType.Call, seqid_);
  oprot_.WriteMessageBegin( _msg17 );
  _args16 := TCalculate_argsImpl.Create();
  _args16.Logid := logid;
  _args16.W := w;
  _args16.Write(oprot_);
  _args16.Logid := 0;
  _args16.W := nil;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TCalculator.TClient.recv_calculate(): System.Integer;
var
  _msg17 : Thrift.Protocol.TThriftMessage;
  _ex18 : Exception;
  _ax19 : TApplicationException;
  _ret20 : ICalculate_result;
begin
  _msg17 := iprot_.ReadMessageBegin();
  if (_msg17.Type_ = TMessageType.Exception) then
  begin
    _ax19 := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise _ax19;
  end;
  _ret20 := TCalculate_resultImpl.Create();
  _ret20.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (_ret20.__isset_success) then
  begin
    Result := _ret20.Success;
    Exit;
  end;
  if (_ret20.__isset_Ouch) then
  begin
    _ex18 := _ret20.Ouch.CreateException;
    raise _ex18;
  end;
  raise TApplicationExceptionMissingResult.Create('calculate failed: unknown result');
end;

procedure TCalculator.TClient.zip();
begin
  send_zip();
end;

procedure TCalculator.TClient.send_zip();
var
  _args21 : IZip_args;
  _msg22 : Thrift.Protocol.TThriftMessage;
begin
  seqid_ := seqid_ + 1;
  Thrift.Protocol.Init( _msg22, 'zip', TMessageType.Oneway, seqid_);
  oprot_.WriteMessageBegin( _msg22 );
  _args21 := TZip_argsImpl.Create();
  _args21.Write(oprot_);
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

constructor TCalculator.TProcessorImpl.Create( iface_: Iface );
begin
  inherited Create( iface_);
  Self.iface_ := iface_;
  ASSERT( processMap_ <> nil);  // inherited
  processMap_.AddOrSetValue( 'ping', ping_Process);
  processMap_.AddOrSetValue( 'pesquisaPontos', pesquisaPontos_Process);
  processMap_.AddOrSetValue( 'calculate', calculate_Process);
  processMap_.AddOrSetValue( 'zip', zip_Process);
end;

destructor TCalculator.TProcessorImpl.Destroy;
begin
  inherited;
end;

function TCalculator.TProcessorImpl.Process( const iprot: IProtocol; const oprot: IProtocol; const events : IProcessorEvents): System.Boolean;
var
  msg : Thrift.Protocol.TThriftMessage;
  fn : TProcessFunction;
  x : TApplicationException;
begin
  try
    msg := iprot.ReadMessageBegin();
    fn := nil;
    if not processMap_.TryGetValue(msg.Name, fn)
    or not Assigned(fn) then
    begin
      TProtocolUtil.Skip(iprot, TType.Struct);
      iprot.ReadMessageEnd();
      x := TApplicationExceptionUnknownMethod.Create('Invalid method name: ''' + msg.Name + '''');
      Thrift.Protocol.Init( msg, msg.Name, TMessageType.Exception, msg.SeqID);
      oprot.WriteMessageBegin( msg);
      x.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
      Result := True;
      Exit;
    end;
    fn(msg.SeqID, iprot, oprot);
  except
    on TTransportExceptionTimedOut do begin
      Result := True;
      Exit;
    end;
    else begin
      Result := False;
      Exit;
    end;
  end;
  Result := True;
end;

// both way processor
procedure TCalculator.TProcessorImpl.ping_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
var
  args: IPing_args;
  msg: Thrift.Protocol.TThriftMessage;
  ret: IPing_result;
  appx : TApplicationException;
begin
  args := TPing_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TPing_resultImpl.Create;
  try
    iface_.ping();
  except
    on E: Exception do begin
      appx := TApplicationExceptionInternalError.Create(E.Message);
      try
        Thrift.Protocol.Init( msg, 'ping', TMessageType.Exception, seqid);
        oprot.WriteMessageBegin( msg);
        appx.Write(oprot);
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
        Exit;
      finally
        appx.Free;
      end;
    end;
  end;
  Thrift.Protocol.Init( msg, 'ping', TMessageType.Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TCalculator.TProcessorImpl.pesquisaPontos_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
var
  args: IAdd_args;
  msg: Thrift.Protocol.TThriftMessage;
  ret: IAdd_result;
  appx : TApplicationException;
begin
  args := TAdd_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TAdd_resultImpl.Create;
  try
    ret.Success := iface_.pesquisaPontos(args.Num1, args.Num2);
    args.Num1 := 0;
    args.Num2 := 0;
  except
    on E: Exception do begin
      appx := TApplicationExceptionInternalError.Create(E.Message);
      try
        Thrift.Protocol.Init( msg, 'pesquisaPontos_Process', TMessageType.Exception, seqid);
        oprot.WriteMessageBegin( msg);
        appx.Write(oprot);
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
        Exit;
      finally
        appx.Free;
      end;
    end;
  end;
  Thrift.Protocol.Init( msg, 'pesquisaPontos_Process', TMessageType.Reply, seqid);
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// both way processor
procedure TCalculator.TProcessorImpl.calculate_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
var
  args: ICalculate_args;
  msg: Thrift.Protocol.TThriftMessage;
  ret: ICalculate_result;
  appx : TApplicationException;
begin
  args := TCalculate_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TCalculate_resultImpl.Create;
  try
    ret.Success := iface_.calculate(args.Logid, args.W);
    args.Logid := 0;
    args.W := nil;
  except
    on E: TInvalidOperation do begin
      ret.Ouch := E.InvalidOperationFactory;
    end;
    on E: Exception do begin
      appx := TApplicationExceptionInternalError.Create(E.Message);
      try
        Thrift.Protocol.Init( msg, 'calculate', TMessageType.Exception, seqid);
        oprot.WriteMessageBegin( msg);
        appx.Write(oprot);
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
        Exit;
      finally
        appx.Free;
      end;
    end;
  end;
  Thrift.Protocol.Init( msg, 'calculate', TMessageType.Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

// one way processor
procedure TCalculator.TProcessorImpl.zip_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
var
  args: IZip_args;
begin
  args := TZip_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  try
    iface_.zip();
  except
    on E: Exception do begin
    end;
  end;
end;

constructor TCalculator.TPing_argsImpl.Create;
begin
  inherited;
end;

destructor TCalculator.TPing_argsImpl.Destroy;
begin
  inherited;
end;

procedure TCalculator.TPing_argsImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculator.TPing_argsImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'ping_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculator.TPing_argsImpl.ToString: string;
var
  _sb23 : TThriftStringBuilder;
begin
  _sb23 := TThriftStringBuilder.Create('(');
  try
    _sb23.Append(')');
    Result := _sb23.ToString;
  finally
    _sb23.Free;
  end;
end;

constructor TCalculator.TPing_resultImpl.Create;
begin
  inherited;
end;

destructor TCalculator.TPing_resultImpl.Destroy;
begin
  inherited;
end;

procedure TCalculator.TPing_resultImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculator.TPing_resultImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'ping_result');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculator.TPing_resultImpl.ToString: string;
var
  _sb25 : TThriftStringBuilder;
begin
  _sb25 := TThriftStringBuilder.Create('(');
  try
    _sb25.Append(')');
    Result := _sb25.ToString;
  finally
    _sb25.Free;
  end;
end;

constructor TCalculator.TAdd_argsImpl.Create;
begin
  inherited;
end;

destructor TCalculator.TAdd_argsImpl.Destroy;
begin
  inherited;
end;

function TCalculator.TAdd_argsImpl.GetNum1: System.Integer;
begin
  Result := FNum1;
end;

procedure TCalculator.TAdd_argsImpl.SetNum1( const Value: System.Integer);
begin
  F__isset_Num1 := True;
  FNum1 := Value;
end;

function TCalculator.TAdd_argsImpl.Get__isset_Num1: System.Boolean;
begin
  Result := F__isset_Num1;
end;

function TCalculator.TAdd_argsImpl.GetNum2: System.Integer;
begin
  Result := FNum2;
end;

procedure TCalculator.TAdd_argsImpl.SetNum2( const Value: System.Integer);
begin
  F__isset_Num2 := True;
  FNum2 := Value;
end;

function TCalculator.TAdd_argsImpl.Get__isset_Num2: System.Boolean;
begin
  Result := F__isset_Num2;
end;

procedure TCalculator.TAdd_argsImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Num1 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Num2 := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculator.TAdd_argsImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'add_args');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Num1) then begin
    field_.Name := 'num1';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Num1);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Num2) then begin
    field_.Name := 'num2';
    field_.Type_  := TType.I32;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Num2);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculator.TAdd_argsImpl.ToString: string;
var
  _sb27 : TThriftStringBuilder;
  _first28 : System.Boolean;
begin
  _sb27 := TThriftStringBuilder.Create('(');
  try
    _first28 := TRUE;
    if (__isset_Num1) then begin
      if not _first28 then _sb27.Append(',');
      _first28 := FALSE;
      _sb27.Append('Num1: ');
      _sb27.Append( Self.Num1);
    end;
    if (__isset_Num2) then begin
      if not _first28 then _sb27.Append(',');
      _first28 := FALSE;
      _sb27.Append('Num2: ');
      _sb27.Append( Self.Num2);
    end;
    _sb27.Append(')');
    Result := _sb27.ToString;
    if _first28 then {prevent warning};
  finally
    _sb27.Free;
  end;
end;

constructor TCalculator.TAdd_resultImpl.Create;
begin
  inherited;
end;

destructor TCalculator.TAdd_resultImpl.Destroy;
begin
  inherited;
end;

function TCalculator.TAdd_resultImpl.GetSuccess: System.Integer;
begin
  Result := FSuccess;
end;

procedure TCalculator.TAdd_resultImpl.SetSuccess( const Value: System.Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TCalculator.TAdd_resultImpl.Get__isset_Success: System.Boolean;
begin
  Result := F__isset_Success;
end;

procedure TCalculator.TAdd_resultImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Success := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculator.TAdd_resultImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'add_result');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Success) then begin
    field_.Name := 'Success';
    field_.Type_  := TType.I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Success);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculator.TAdd_resultImpl.ToString: string;
var
  _sb29 : TThriftStringBuilder;
  _first30 : System.Boolean;
begin
  _sb29 := TThriftStringBuilder.Create('(');
  try
    _first30 := TRUE;
    if (__isset_Success) then begin
      if not _first30 then _sb29.Append(',');
      _first30 := FALSE;
      _sb29.Append('Success: ');
      _sb29.Append( Self.Success);
    end;
    _sb29.Append(')');
    Result := _sb29.ToString;
    if _first30 then {prevent warning};
  finally
    _sb29.Free;
  end;
end;

constructor TCalculator.TCalculate_argsImpl.Create;
begin
  inherited;
end;

destructor TCalculator.TCalculate_argsImpl.Destroy;
begin
  inherited;
end;

function TCalculator.TCalculate_argsImpl.GetLogid: System.Integer;
begin
  Result := FLogid;
end;

procedure TCalculator.TCalculate_argsImpl.SetLogid( const Value: System.Integer);
begin
  F__isset_Logid := True;
  FLogid := Value;
end;

function TCalculator.TCalculate_argsImpl.Get__isset_Logid: System.Boolean;
begin
  Result := F__isset_Logid;
end;

function TCalculator.TCalculate_argsImpl.GetW: IWork;
begin
  Result := FW;
end;

procedure TCalculator.TCalculate_argsImpl.SetW( const Value: IWork);
begin
  F__isset_W := True;
  FW := Value;
end;

function TCalculator.TCalculate_argsImpl.Get__isset_W: System.Boolean;
begin
  Result := F__isset_W;
end;

procedure TCalculator.TCalculate_argsImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Logid := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = TType.Struct) then begin
            Self.W := TWorkImpl.Create;
            Self.W.Read(iprot);
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculator.TCalculate_argsImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'calculate_args');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Logid) then begin
    field_.Name := 'logid';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Logid);
    oprot.WriteFieldEnd();
  end;
  if (Self.W <> nil) and __isset_W then begin
    field_.Name := 'w';
    field_.Type_  := TType.Struct;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    Self.W.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculator.TCalculate_argsImpl.ToString: string;
var
  _sb31 : TThriftStringBuilder;
  _first32 : System.Boolean;
begin
  _sb31 := TThriftStringBuilder.Create('(');
  try
    _first32 := TRUE;
    if (__isset_Logid) then begin
      if not _first32 then _sb31.Append(',');
      _first32 := FALSE;
      _sb31.Append('Logid: ');
      _sb31.Append( Self.Logid);
    end;
    if (Self.W <> nil) and __isset_W then begin
      if not _first32 then _sb31.Append(',');
      _first32 := FALSE;
      _sb31.Append('W: ');
      if (Self.W = nil) then _sb31.Append('<null>') else _sb31.Append( Self.W.ToString());
    end;
    _sb31.Append(')');
    Result := _sb31.ToString;
    if _first32 then {prevent warning};
  finally
    _sb31.Free;
  end;
end;

constructor TCalculator.TCalculate_resultImpl.Create;
begin
  inherited;
end;

destructor TCalculator.TCalculate_resultImpl.Destroy;
begin
  inherited;
end;

function TCalculator.TCalculate_resultImpl.GetSuccess: System.Integer;
begin
  Result := FSuccess;
end;

procedure TCalculator.TCalculate_resultImpl.SetSuccess( const Value: System.Integer);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TCalculator.TCalculate_resultImpl.Get__isset_Success: System.Boolean;
begin
  Result := F__isset_Success;
end;

function TCalculator.TCalculate_resultImpl.GetOuch: TInvalidOperation.IInvalidOperationFactory;
begin
  Result := FOuch;
end;

procedure TCalculator.TCalculate_resultImpl.SetOuch( const Value: TInvalidOperation.IInvalidOperationFactory);
begin
  F__isset_Ouch := True;
  FOuch := Value;
end;

function TCalculator.TCalculate_resultImpl.Get__isset_Ouch: System.Boolean;
begin
  Result := F__isset_Ouch;
end;

procedure TCalculator.TCalculate_resultImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Success := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        1: begin
          if (field_.Type_ = TType.Struct) then begin
            Self.Ouch := TInvalidOperation.TInvalidOperationFactoryImpl.Create;
            Self.Ouch.Read(iprot);
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculator.TCalculate_resultImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'calculate_result');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Success) then begin
    field_.Name := 'Success';
    field_.Type_  := TType.I32;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Success);
    oprot.WriteFieldEnd();
  end;
  if (Self.Ouch <> nil) and __isset_Ouch then begin
    field_.Name := 'ouch';
    field_.Type_  := TType.Struct;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    Self.Ouch.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculator.TCalculate_resultImpl.ToString: string;
var
  _sb33 : TThriftStringBuilder;
  _first34 : System.Boolean;
begin
  _sb33 := TThriftStringBuilder.Create('(');
  try
    _first34 := TRUE;
    if (__isset_Success) then begin
      if not _first34 then _sb33.Append(',');
      _first34 := FALSE;
      _sb33.Append('Success: ');
      _sb33.Append( Self.Success);
    end;
    if (Self.Ouch <> nil) and __isset_Ouch then begin
      if not _first34 then _sb33.Append(',');
      _first34 := FALSE;
      _sb33.Append('Ouch: ');
      if (Self.Ouch = nil) then _sb33.Append('<null>') else _sb33.Append( Self.Ouch.ToString());
    end;
    _sb33.Append(')');
    Result := _sb33.ToString;
    if _first34 then {prevent warning};
  finally
    _sb33.Free;
  end;
end;

constructor TCalculator.TZip_argsImpl.Create;
begin
  inherited;
end;

destructor TCalculator.TZip_argsImpl.Destroy;
begin
  inherited;
end;

procedure TCalculator.TZip_argsImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      TProtocolUtil.Skip(iprot, field_.Type_);
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TCalculator.TZip_argsImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'zip_args');
  oprot.WriteStructBegin(struc);
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TCalculator.TZip_argsImpl.ToString: string;
var
  _sb35 : TThriftStringBuilder;
begin
  _sb35 := TThriftStringBuilder.Create('(');
  try
    _sb35.Append(')');
    Result := _sb35.ToString;
  finally
    _sb35.Free;
  end;
end;

{$IF CompilerVersion >= 21.0}
class constructor TConstants.Create;
begin
  FMAPCONSTANT := TThriftDictionaryImpl<System.string, System.string>.Create;
  FMAPCONSTANT['goodnight'] := 'moon';
  FMAPCONSTANT['hello'] := 'world';
end;

class destructor TConstants.Destroy;
begin
  inherited;
end;
{$ELSE}
procedure TConstants_Initialize;
begin
  TConstants.FMAPCONSTANT := TThriftDictionaryImpl<System.string, System.string>.Create;
  TConstants.FMAPCONSTANT['goodnight'] := 'moon';
  TConstants.FMAPCONSTANT['hello'] := 'world';
end;

procedure TConstants_Finalize;
begin
end;
{$IFEND}


initialization
{$IF CompilerVersion < 21.0}  // D2010
  TConstants_Initialize;
{$IFEND}

finalization
{$IF CompilerVersion < 21.0}  // D2010
  TConstants_Finalize;
{$IFEND}


end.
