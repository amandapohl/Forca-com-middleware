(**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *)

unit shared;

interface

uses
  Classes,
  SysUtils,
  Generics.Collections,
  Thrift,
  Thrift.Utils,
  Thrift.Collections,
  Thrift.Protocol,
  Thrift.Transport;

const
  cshared_Option_AnsiStr_Binary = False;
  cshared_Option_Register_Types = False;
  cshared_Option_ConstPrefix    = False;
  cshared_Option_Events         = False;
  cshared_Option_XmlDoc         = False;

type
  ISharedStruct = interface;

  ISharedStruct = interface(IBase)
    function GetKey: System.Integer;
    procedure SetKey( const Value: System.Integer);
    function GetValue: System.string;
    procedure SetValue( const Value: System.string);

    property Key: System.Integer read GetKey write SetKey;
    property Value: System.string read GetValue write SetValue;

    function Get__isset_Key: System.Boolean;
    function Get__isset_Value: System.Boolean;

    property __isset_Key: System.Boolean read Get__isset_Key;
    property __isset_Value: System.Boolean read Get__isset_Value;
  end;

  TSharedStructImpl = class(TInterfacedObject, IBase, ISupportsToString, ISharedStruct)
  private
    FKey: System.Integer;
    FValue: System.string;
    
    F__isset_Key: System.Boolean;
    F__isset_Value: System.Boolean;
    
    function GetKey: System.Integer;
    procedure SetKey( const Value: System.Integer);
    function GetValue: System.string;
    procedure SetValue( const Value: System.string);

    function Get__isset_Key: System.Boolean;
    function Get__isset_Value: System.Boolean;
  public
    constructor Create;
    destructor Destroy; override;

    function ToString: string; override;

    // IBase
    procedure Read( const iprot: IProtocol);
    procedure Write( const oprot: IProtocol);

    // Properties
    property Key: System.Integer read GetKey write SetKey;
    property Value: System.string read GetValue write SetValue;

    // isset
    property __isset_Key: System.Boolean read Get__isset_Key;
    property __isset_Value: System.Boolean read Get__isset_Value;
  end;

  TSharedService = class
  public
    type
      Iface = interface
        function getStruct(key: System.Integer): ISharedStruct;
      end;

      TClient = class( TInterfacedObject, Iface)
      public
        constructor Create( prot: IProtocol); overload;
        constructor Create( const iprot: IProtocol; const oprot: IProtocol); overload;
      protected
        iprot_: IProtocol;
        oprot_: IProtocol;
        seqid_: System.Integer;
      public
        property InputProtocol: IProtocol read iprot_;
        property OutputProtocol: IProtocol read oprot_;
      protected
        // Iface
        function getStruct(key: System.Integer): ISharedStruct;
      public
        procedure send_getStruct(key: System.Integer);
        function recv_getStruct(): ISharedStruct;
      end;

      TProcessorImpl = class( TInterfacedObject, IProcessor)
      public
        constructor Create( iface_: Iface );
        destructor Destroy; override;
      private
        iface_: Iface;
      protected
        type
          TProcessFunction = reference to procedure( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
      protected
        processMap_: IThriftDictionary<string, TProcessFunction>;
      public
        function Process( const iprot: IProtocol; const oprot: IProtocol; const events : IProcessorEvents): System.Boolean;
        procedure getStruct_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
      end;

      IGetStruct_args = interface(IBase)
        function GetKey: System.Integer;
        procedure SetKey( const Value: System.Integer);

        property Key: System.Integer read GetKey write SetKey;

        function Get__isset_Key: System.Boolean;

        property __isset_Key: System.Boolean read Get__isset_Key;
      end;

      TGetStruct_argsImpl = class(TInterfacedObject, IBase, ISupportsToString, IGetStruct_args)
      private
        FKey: System.Integer;
        
        F__isset_Key: System.Boolean;
        
        function GetKey: System.Integer;
        procedure SetKey( const Value: System.Integer);

        function Get__isset_Key: System.Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Key: System.Integer read GetKey write SetKey;

        // isset
        property __isset_Key: System.Boolean read Get__isset_Key;
      end;

      IGetStruct_result = interface(IBase)
        function GetSuccess: ISharedStruct;
        procedure SetSuccess( const Value: ISharedStruct);

        property Success: ISharedStruct read GetSuccess write SetSuccess;

        function Get__isset_Success: System.Boolean;

        property __isset_Success: System.Boolean read Get__isset_Success;
      end;

      TGetStruct_resultImpl = class(TInterfacedObject, IBase, ISupportsToString, IGetStruct_result)
      private
        FSuccess: ISharedStruct;
        
        F__isset_Success: System.Boolean;
        
        function GetSuccess: ISharedStruct;
        procedure SetSuccess( const Value: ISharedStruct);

        function Get__isset_Success: System.Boolean;
      public
        constructor Create;
        destructor Destroy; override;

        function ToString: string; override;

        // IBase
        procedure Read( const iprot: IProtocol);
        procedure Write( const oprot: IProtocol);

        // Properties
        property Success: ISharedStruct read GetSuccess write SetSuccess;

        // isset
        property __isset_Success: System.Boolean read Get__isset_Success;
      end;

  end;
  
implementation

constructor TSharedStructImpl.Create;
begin
  inherited;
end;

destructor TSharedStructImpl.Destroy;
begin
  inherited;
end;

function TSharedStructImpl.GetKey: System.Integer;
begin
  Result := FKey;
end;

procedure TSharedStructImpl.SetKey( const Value: System.Integer);
begin
  F__isset_Key := True;
  FKey := Value;
end;

function TSharedStructImpl.Get__isset_Key: System.Boolean;
begin
  Result := F__isset_Key;
end;

function TSharedStructImpl.GetValue: System.string;
begin
  Result := FValue;
end;

procedure TSharedStructImpl.SetValue( const Value: System.string);
begin
  F__isset_Value := True;
  FValue := Value;
end;

function TSharedStructImpl.Get__isset_Value: System.Boolean;
begin
  Result := F__isset_Value;
end;

procedure TSharedStructImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Key := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end;
        2: begin
          if (field_.Type_ = TType.String_) then begin
            Self.Value := iprot.ReadString();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSharedStructImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'SharedStruct');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Key) then begin
    field_.Name := 'key';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Key);
    oprot.WriteFieldEnd();
  end;
  if (__isset_Value) then begin
    field_.Name := 'value';
    field_.Type_  := TType.String_;
    field_.ID := 2;
    oprot.WriteFieldBegin(field_);
    oprot.WriteString(Self.Value);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSharedStructImpl.ToString: string;
var
  _sb0 : TThriftStringBuilder;
  _first1 : System.Boolean;
begin
  _sb0 := TThriftStringBuilder.Create('(');
  try
    _first1 := TRUE;
    if (__isset_Key) then begin
      if not _first1 then _sb0.Append(',');
      _first1 := FALSE;
      _sb0.Append('Key: ');
      _sb0.Append( Self.Key);
    end;
    if (__isset_Value) then begin
      if not _first1 then _sb0.Append(',');
      _first1 := FALSE;
      _sb0.Append('Value: ');
      _sb0.Append( Self.Value);
    end;
    _sb0.Append(')');
    Result := _sb0.ToString;
    if _first1 then {prevent warning};
  finally
    _sb0.Free;
  end;
end;

constructor TSharedService.TClient.Create( prot: IProtocol);
begin
  Create( prot, prot );
end;

constructor TSharedService.TClient.Create( const iprot: IProtocol; const oprot: IProtocol);
begin
  inherited Create;
  iprot_ := iprot;
  oprot_ := oprot;
end;

function TSharedService.TClient.getStruct(key: System.Integer): ISharedStruct;
begin
  send_getStruct(key);
  Result := recv_getStruct();
end;

procedure TSharedService.TClient.send_getStruct(key: System.Integer);
var
  _args2 : IGetStruct_args;
  _msg3 : Thrift.Protocol.TThriftMessage;
begin
  seqid_ := seqid_ + 1;
  Thrift.Protocol.Init( _msg3, 'getStruct', TMessageType.Call, seqid_);
  oprot_.WriteMessageBegin( _msg3 );
  _args2 := TGetStruct_argsImpl.Create();
  _args2.Key := key;
  _args2.Write(oprot_);
  _args2.Key := 0;
  oprot_.WriteMessageEnd();
  oprot_.Transport.Flush();
end;

function TSharedService.TClient.recv_getStruct(): ISharedStruct;
var
  _msg3 : Thrift.Protocol.TThriftMessage;
  _ax5 : TApplicationException;
  _ret6 : IGetStruct_result;
begin
  _msg3 := iprot_.ReadMessageBegin();
  if (_msg3.Type_ = TMessageType.Exception) then
  begin
    _ax5 := TApplicationException.Read(iprot_);
    iprot_.ReadMessageEnd();
    raise _ax5;
  end;
  _ret6 := TGetStruct_resultImpl.Create();
  _ret6.Read(iprot_);
  iprot_.ReadMessageEnd();
  if (_ret6.__isset_success) then
  begin
    Result := _ret6.Success;
    _ret6.Success := nil;
    Exit;
  end;
  raise TApplicationExceptionMissingResult.Create('getStruct failed: unknown result');
end;

constructor TSharedService.TProcessorImpl.Create( iface_: Iface );
begin
  inherited Create;
  Self.iface_ := iface_;
  processMap_ := TThriftDictionaryImpl<string, TProcessFunction>.Create;
  processMap_.AddOrSetValue( 'getStruct', getStruct_Process);
end;

destructor TSharedService.TProcessorImpl.Destroy;
begin
  inherited;
end;

function TSharedService.TProcessorImpl.Process( const iprot: IProtocol; const oprot: IProtocol; const events : IProcessorEvents): System.Boolean;
var
  msg : Thrift.Protocol.TThriftMessage;
  fn : TProcessFunction;
  x : TApplicationException;
begin
  try
    msg := iprot.ReadMessageBegin();
    fn := nil;
    if not processMap_.TryGetValue(msg.Name, fn)
    or not Assigned(fn) then
    begin
      TProtocolUtil.Skip(iprot, TType.Struct);
      iprot.ReadMessageEnd();
      x := TApplicationExceptionUnknownMethod.Create('Invalid method name: ''' + msg.Name + '''');
      Thrift.Protocol.Init( msg, msg.Name, TMessageType.Exception, msg.SeqID);
      oprot.WriteMessageBegin( msg);
      x.Write(oprot);
      oprot.WriteMessageEnd();
      oprot.Transport.Flush();
      Result := True;
      Exit;
    end;
    fn(msg.SeqID, iprot, oprot);
  except
    on TTransportExceptionTimedOut do begin
      Result := True;
      Exit;
    end;
    else begin
      Result := False;
      Exit;
    end;
  end;
  Result := True;
end;

// both way processor
procedure TSharedService.TProcessorImpl.getStruct_Process( seqid: System.Integer; const iprot: IProtocol; const oprot: IProtocol);
var
  args: IGetStruct_args;
  msg: Thrift.Protocol.TThriftMessage;
  ret: IGetStruct_result;
  appx : TApplicationException;
begin
  args := TGetStruct_argsImpl.Create;
  args.Read(iprot);
  iprot.ReadMessageEnd();
  ret := TGetStruct_resultImpl.Create;
  try
    ret.Success := iface_.getStruct(args.Key);
    args.Key := 0;
  except
    on E: Exception do begin
      appx := TApplicationExceptionInternalError.Create(E.Message);
      try
        Thrift.Protocol.Init( msg, 'getStruct', TMessageType.Exception, seqid);
        oprot.WriteMessageBegin( msg);
        appx.Write(oprot);
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
        Exit;
      finally
        appx.Free;
      end;
    end;
  end;
  Thrift.Protocol.Init( msg, 'getStruct', TMessageType.Reply, seqid); 
  oprot.WriteMessageBegin( msg); 
  ret.Write(oprot);
  oprot.WriteMessageEnd();
  oprot.Transport.Flush();
end;

constructor TSharedService.TGetStruct_argsImpl.Create;
begin
  inherited;
end;

destructor TSharedService.TGetStruct_argsImpl.Destroy;
begin
  inherited;
end;

function TSharedService.TGetStruct_argsImpl.GetKey: System.Integer;
begin
  Result := FKey;
end;

procedure TSharedService.TGetStruct_argsImpl.SetKey( const Value: System.Integer);
begin
  F__isset_Key := True;
  FKey := Value;
end;

function TSharedService.TGetStruct_argsImpl.Get__isset_Key: System.Boolean;
begin
  Result := F__isset_Key;
end;

procedure TSharedService.TGetStruct_argsImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        1: begin
          if (field_.Type_ = TType.I32) then begin
            Self.Key := iprot.ReadI32();
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSharedService.TGetStruct_argsImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'getStruct_args');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (__isset_Key) then begin
    field_.Name := 'key';
    field_.Type_  := TType.I32;
    field_.ID := 1;
    oprot.WriteFieldBegin(field_);
    oprot.WriteI32(Self.Key);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSharedService.TGetStruct_argsImpl.ToString: string;
var
  _sb7 : TThriftStringBuilder;
  _first8 : System.Boolean;
begin
  _sb7 := TThriftStringBuilder.Create('(');
  try
    _first8 := TRUE;
    if (__isset_Key) then begin
      if not _first8 then _sb7.Append(',');
      _first8 := FALSE;
      _sb7.Append('Key: ');
      _sb7.Append( Self.Key);
    end;
    _sb7.Append(')');
    Result := _sb7.ToString;
    if _first8 then {prevent warning};
  finally
    _sb7.Free;
  end;
end;

constructor TSharedService.TGetStruct_resultImpl.Create;
begin
  inherited;
end;

destructor TSharedService.TGetStruct_resultImpl.Destroy;
begin
  inherited;
end;

function TSharedService.TGetStruct_resultImpl.GetSuccess: ISharedStruct;
begin
  Result := FSuccess;
end;

procedure TSharedService.TGetStruct_resultImpl.SetSuccess( const Value: ISharedStruct);
begin
  F__isset_Success := True;
  FSuccess := Value;
end;

function TSharedService.TGetStruct_resultImpl.Get__isset_Success: System.Boolean;
begin
  Result := F__isset_Success;
end;

procedure TSharedService.TGetStruct_resultImpl.Read( const iprot: IProtocol);
var
  field_ : TThriftField;
  struc : TThriftStruct;
  tracker : IProtocolRecursionTracker;

begin
  tracker := iprot.NextRecursionLevel;
  struc := iprot.ReadStructBegin;
  try
    while (true) do
    begin
      field_ := iprot.ReadFieldBegin();
      if (field_.Type_ = TType.Stop) then
      begin
        Break;
      end;
      case field_.ID of
        0: begin
          if (field_.Type_ = TType.Struct) then begin
            Self.Success := TSharedStructImpl.Create;
            Self.Success.Read(iprot);
          end else begin
            TProtocolUtil.Skip(iprot, field_.Type_);
          end;
        end
        else begin
          TProtocolUtil.Skip(iprot, field_.Type_);
        end;
      end;
      iprot.ReadFieldEnd;
    end;
  finally
    iprot.ReadStructEnd;
  end;
end;

procedure TSharedService.TGetStruct_resultImpl.Write( const oprot: IProtocol);
var
  struc : TThriftStruct;
  field_ : TThriftField;
  tracker : IProtocolRecursionTracker;
begin
  tracker := oprot.NextRecursionLevel;
  Thrift.Protocol.Init( struc, 'getStruct_result');
  oprot.WriteStructBegin(struc);
  Thrift.Protocol.Init( field_);
  if (Self.Success <> nil) and __isset_Success then begin
    field_.Name := 'Success';
    field_.Type_  := TType.Struct;
    field_.ID := 0;
    oprot.WriteFieldBegin(field_);
    Self.Success.Write(oprot);
    oprot.WriteFieldEnd();
  end;
  oprot.WriteFieldStop();
  oprot.WriteStructEnd();
end;

function TSharedService.TGetStruct_resultImpl.ToString: string;
var
  _sb9 : TThriftStringBuilder;
  _first10 : System.Boolean;
begin
  _sb9 := TThriftStringBuilder.Create('(');
  try
    _first10 := TRUE;
    if (Self.Success <> nil) and __isset_Success then begin
      if not _first10 then _sb9.Append(',');
      _first10 := FALSE;
      _sb9.Append('Success: ');
      if (Self.Success = nil) then _sb9.Append('<null>') else _sb9.Append( Self.Success.ToString());
    end;
    _sb9.Append(')');
    Result := _sb9.ToString;
    if _first10 then {prevent warning};
  finally
    _sb9.Free;
  end;
end;


initialization

finalization


end.
